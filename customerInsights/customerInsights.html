<!DOCTYPE html>
<!-- Created as an example by https://github.com/mcphee11 Version 4.1 -->
<html>
  <head>
    <meta name="robots" content="noindex" />
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <title></title>
    <meta name="Template" content="" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <!-- Genesys CSS https://spark.genesys.com/ In PROD set a version https://www.jsdelivr.com/package/npm/genesys-spark-components -->
    <link no-cors href="https://cdn.jsdelivr.net/npm/genesys-spark-components@4.156.4/dist/genesys-webcomponents/genesys-webcomponents.min.css" rel="stylesheet" />
    <script no-cors type="module" src="https://cdn.jsdelivr.net/npm/genesys-spark-components@4.156.4/dist/genesys-webcomponents/genesys-webcomponents.esm.min.js"></script>
    <!-- Genesys SDK info https://developer.genesys.cloud/  In PROD set a version -->
    <script src="https://sdk-cdn.mypurecloud.com/javascript/latest/purecloud-platform-client-v2.min.js"></script>
    <script src="https://sdk-cdn.mypurecloud.com/client-apps/2.6.7/purecloud-client-app-sdk.js"></script>
    <!-- custom charts -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.5.0/dist/chart.umd.min.js"></script>
  </head>
  <body onload="start()">
    <div style="display: inline-flex" class="header">
      <gux-dropdown filter-type="starts-with" placeholder="UTC-00:00" id="timeZone" style="width: 150px; padding: 8px">
        <gux-listbox aria-label="Time Zone">
          <gux-option value="-12:00">UTC-12:00</gux-option><gux-option value="-11:00">UTC-11:00</gux-option><gux-option value="-10:00">UTC-10:00</gux-option
          ><gux-option value="-09:30">UTC-09:30</gux-option><gux-option value="-09:00">UTC-09:00</gux-option><gux-option value="-08:00">UTC-08:00</gux-option
          ><gux-option value="-07:00">UTC-07:00</gux-option><gux-option value="-06:00">UTC-06:00</gux-option><gux-option value="-05:00">UTC-05:00</gux-option
          ><gux-option value="-04:00">UTC-04:00</gux-option><gux-option value="-03:30">UTC-03:30</gux-option><gux-option value="-03:00">UTC-03:00</gux-option
          ><gux-option value="-02:00">UTC-02:00</gux-option><gux-option value="-01:00">UTC-01:00</gux-option><gux-option value="-00:00">UTC+00:00</gux-option
          ><gux-option value="+00:00">UTC+00:00</gux-option><gux-option value="+01:00">UTC+01:00</gux-option><gux-option value="+02:00">UTC+02:00</gux-option
          ><gux-option value="+03:00">UTC+03:00</gux-option><gux-option value="+03:30">UTC+03:30</gux-option><gux-option value="+04:00">UTC+04:00</gux-option
          ><gux-option value="+04:30">UTC+04:30</gux-option><gux-option value="+05:00">UTC+05:00</gux-option><gux-option value="+05:30">UTC+05:30</gux-option
          ><gux-option value="+05:45">UTC+05:45</gux-option><gux-option value="+06:00">UTC+06:00</gux-option><gux-option value="+06:30">UTC+06:30</gux-option
          ><gux-option value="+07:00">UTC+07:00</gux-option><gux-option value="+08:00">UTC+08:00</gux-option><gux-option value="+08:45">UTC+08:45</gux-option
          ><gux-option value="+09:00">UTC+09:00</gux-option><gux-option value="+09:30">UTC+09:30</gux-option><gux-option value="+10:00">UTC+10:00</gux-option
          ><gux-option value="+10:30">UTC+10:30</gux-option><gux-option value="+11:00">UTC+11:00</gux-option><gux-option value="+12:00">UTC+12:00</gux-option
          ><gux-option value="+12:45">UTC+12:45</gux-option><gux-option value="+13:00">UTC+13:00</gux-option><gux-option value="+14:00">UTC+14:00</gux-option>
        </gux-listbox>
      </gux-dropdown>
      <gux-datepicker id="datepicker" style="padding: 8px" mode="range" value="" number-of-months="2"></gux-datepicker>
      <gux-button style="padding: 8px" accent="secondary" onclick="thisMonth()">This Month</gux-button>
      <gux-button style="padding: 8px" accent="secondary" onclick="last30days()">Last 30 Days</gux-button>
      <gux-button style="padding: 8px" accent="primary" onclick="getData()">Search</gux-button>
      <gux-button style="padding: 8px" accent="secondary" onclick="clearData()">Clear</gux-button>
      <gux-button id="download" style="padding: 8px; display: none" accent="ghost" onclick="buildPDF()">Download</gux-button>
    </div>
    <div id="spinner" style="justify-self: center; padding: 8px; display: none">
      <gux-radial-loading id="loading" class="loading" screenreader-text="Loading..."></gux-radial-loading>
    </div>
    <gux-card accent="raised" class="mm-card">
      <h2>Customer Insights Report</h2>
      <p id="createdDate">Created on:</p>
      <div style="display: inline-flex; width: 100%; height: 200px">
        <div>
          <p>Organization:</p>
          <p id="orgName"></p>
          <p>Org ID:</p>
          <p id="orgId"></p>
          <p>Region:</p>
          <p id="region"></p>
        </div>
        <div style="margin-left: 50%">
          <p>StartDate:</p>
          <p id="startDate"></p>
          <p>endDate:</p>
          <p id="endDate"></p>
        </div>
      </div>
    </gux-card>
    <gux-card accent="raised" class="mm-card">
      <h2>Mean Opinion Score (MOS)</h2>
      <p>
        MOS is a measure of audio quality at a specific measurement point of a voice interaction. Potential measurement points are on-premise or cloud-based Edge devices. Values in the MOS column are
        estimated average MOS scores. The estimated average MOS score for a stream is based on codec type, average jitter, latency, and packet loss. Each MOS score is a number between 1 (unacceptable)
        and 5 (excellent). Scores below 3.5 generally indicate unacceptable quality. Scores between 4.3 and 5 indicate high quality.
      </p>
      <p>MOS is not measured for every interaction.</p>
      <p id="mosLabel" class="mm-center"></p>
    </gux-card>
    <gux-card accent="raised" class="mm-card">
      <h2>R-Factor</h2>
      <p>
        The R-Factor is value derived from metrics such as latency, jitter, and packet loss per ITUâ€‘T Recommendation G.107, the R-Factor value helps you quickly assess the quality-of-experience for
        VoIP calls on your network. Typical scores range from 50 (bad) to 90 (excellent).
      </p>
      <p>R-Factor is not available for every interaction.</p>
      <p id="rFactorLabel" class="mm-center"></p>
    </gux-card>
    <gux-card accent="raised" class="mm-card">
      <h2>Inbound Connected Interactions</h2>
      <div style="display: flex; align-items: center; justify-content: center">
        <div style="width: 70%">
          <canvas id="incomingMediaTypes" class="mm-chart"></canvas>
        </div>
        <div id="inboundTable" style="margin-left: 18px"></div>
      </div>
    </gux-card>
    <gux-card accent="raised" class="mm-card">
      <h2>Outbound Connected Interactions</h2>
      <div style="display: flex; align-items: center; justify-content: center">
        <div style="width: 70%">
          <canvas id="outgoingMediaTypes" class="mm-chart"></canvas>
        </div>
        <div id="outboundTable" style="margin-left: 18px"></div>
      </div>
    </gux-card>
    <gux-card accent="raised" class="mm-card">
      <h2>Recordings</h2>
      <div style="display: flex; align-items: center; justify-content: center">
        <div style="width: 70%">
          <canvas id="recordings" class="mm-chart"></canvas>
        </div>
        <div id="recordingsTable" style="margin-left: 18px"></div>
      </div>
    </gux-card>
    <gux-card accent="raised" class="mm-card">
      <h2>Calls Per Day</h2>
      <canvas id="callsPerDay" class="mm-chart"></canvas>
    </gux-card>
    <gux-card accent="raised" class="mm-card">
      <h2>Emails Per Day</h2>
      <canvas id="emailsPerDay" class="mm-chart"></canvas>
    </gux-card>
    <gux-card accent="raised" class="mm-card">
      <h2>Messages Per Day</h2>
      <canvas id="messagesPerDay" class="mm-chart"></canvas>
    </gux-card>
    <gux-card accent="raised" class="mm-card">
      <h2>Callbacks Per Day</h2>
      <canvas id="callbacksPerDay" class="mm-chart"></canvas>
    </gux-card>
    <gux-card accent="raised" class="mm-card">
      <h2>Interactions Per Day</h2>
      <canvas id="interactionsPerDay" class="mm-chart"></canvas>
    </gux-card>
    <gux-card accent="raised" class="mm-card">
      <h2>Users Per Day</h2>
      <canvas id="usersPerDay" class="mm-chart"></canvas>
    </gux-card>
    <script>
      'use strict' //Enables strict mode is JavaScript
      let url = new URL(document.location.href)
      let gc_region = url.searchParams.get('gc_region')
      let gc_clientId = url.searchParams.get('gc_clientId')
      let gc_redirectUrl = url.searchParams.get('gc_redirectUrl')

      //Getting and setting the GC details from dynamic URL and session storage
      gc_region ? sessionStorage.setItem('gc_region', gc_region) : (gc_region = sessionStorage.getItem('gc_region'))
      gc_clientId ? sessionStorage.setItem('gc_clientId', gc_clientId) : (gc_clientId = sessionStorage.getItem('gc_clientId'))
      gc_redirectUrl ? sessionStorage.setItem('gc_redirectUrl', gc_redirectUrl) : (gc_redirectUrl = sessionStorage.getItem('gc_redirectUrl'))

      let platformClient = require('platformClient')
      const client = platformClient.ApiClient.instance
      const capi = new platformClient.ConversationsApi()
      const uapi = new platformClient.UsersApi()
      const oapi = new platformClient.OrganizationApi()

      // Configure Client App
      const ClientApp = window.purecloud.apps.ClientApp
      const myClientApp = new ClientApp({
        pcEnvironment: gc_region,
      })

      async function start() {
        try {
          client.setEnvironment(gc_region)
          client.setPersistSettings(true, '_mm_')

          console.log('%cLogging in to Genesys Cloud', 'color: green')
          await client.loginPKCEGrant(gc_clientId, gc_redirectUrl, {})
          getUTCOffset()
          thisMonth()
        } catch (err) {
          console.log('Error: ', err)
        }
      }

      function last30days() {
        let today = new Date()
        let aMonthAgo = new Date()
        aMonthAgo.setMonth(aMonthAgo.getMonth() - 1)
        // prettier-ignore
        document.getElementById('datepicker').value = `${aMonthAgo.getFullYear()}-${String(aMonthAgo.getMonth() + 1).padStart(2, '0')}-${String(aMonthAgo.getDate()).padStart(2,'0')}/${today.getFullYear()}-${String(today.getMonth() + 1).padStart(2, '0')}-${String(today.getDate()).padStart(2, '0')}`
      }

      function thisMonth() {
        let today = new Date()
        // prettier-ignore
        document.getElementById('datepicker').value = `${today.getFullYear()}-${String(today.getMonth() + 1).padStart(2, '0')}-01/${today.getFullYear()}-${String(today.getMonth() + 1).padStart(2,'0')}-${String(today.getDate()).padStart(2, '0')}`
      }

      function getUTCOffset() {
        const now = new Date()
        const offsetMinutes = now.getTimezoneOffset()
        const offsetHours = -offsetMinutes / 60 // Invert for standard UTC offset representation

        let offsetString = ''
        if (offsetHours === 0) {
          offsetString = '+00:00'
        } else {
          const sign = offsetHours > 0 ? '+' : '-'
          const absHours = Math.abs(Math.floor(offsetHours))
          const minutes = Math.abs(Math.floor((offsetHours - absHours) * 60))
          const hoursString = absHours.toString().padStart(2, '0')
          const minutesString = minutes.toString().padStart(2, '0')
          offsetString = `${sign}${hoursString}:${minutesString}`
        }
        document.getElementById('timeZone').value = offsetString
      }

      // save pdf
      function buildPDF() {
        window.print()
      }

      async function clearData() {
        console.log('%cClearing data', 'color: green')
        let mm_center = document.getElementsByClassName('mm-center')
        let mm_chart = document.getElementsByClassName('mm-chart')
        for (const center of mm_center) {
          center.innerHTML = ''
        }
        for (const chart of mm_chart) {
          chart.innerHTML = ''
        }
        document.getElementById('createdDate').innerHTML = `Created on: `
        document.getElementById('orgName').innerHTML = ''
        document.getElementById('orgId').innerHTML = ''
        document.getElementById('region').innerHTML = ''
        document.getElementById('startDate').innerHTML = ''
        document.getElementById('endDate').innerHTML = ''

        document.getElementById('spinner').style.display = 'none'
        document.getElementById('download').style.display = 'none'
      }

      function notification(type, message) {
        if (window.location !== window.parent.location) {
          // if in an iframe
          myClientApp.alerting.showToastPopup(type, message)
          return
        }
        window.alert(message)
        return
      }

      // dynamic table creation
      async function buildTableRows(location, rows) {
        for (const row of rows) {
          let tableBody = document.getElementById(location)
          if (!tableBody) {
            // create the top table row if its not already there
            console.log('Creating table')
            let top = document.getElementById('tableLocation')
            let guxTable = document.createElement('gux-table')
            let table = document.createElement('table')
            let header = document.createElement('thead')
            let headerRow = document.createElement('tr')
            let tbody = document.createElement('tbody')

            headerRow.setAttribute('data-row-id', 'head')
            tbody.setAttribute('id', 'tableBody')
            table.setAttribute('slot', 'data')
            guxTable.setAttribute('resizable-columns', '')

            header.appendChild(headerRow)
            guxTable.appendChild(table)
            table.appendChild(header)
            table.appendChild(tbody)

            // create column names on first row
            for (const item of row) {
              let th = document.createElement('th')
              th.setAttribute('data-column-name', item)
              th.style.textWrap = 'auto'
              th.innerHTML = item
              th.title = item
              headerRow.appendChild(th)
            }
            top.appendChild(guxTable)
            continue
          }
          if (tableBody) {
            // add data to the row
            let tr = document.createElement('tr')
            for (const item of row) {
              let column = document.createElement('td')
              column.innerHTML = item
              tr.appendChild(column)
            }
            tableBody.appendChild(tr)
          }
        }
      }

      async function setReportData() {
        let today = new Date()
        document.getElementById('createdDate').innerHTML = `Created on: <strong>${today}</strong>`
        const org = await oapi.getOrganizationsMe()
        document.getElementById('orgName').innerHTML = `<strong>${org.name}</strong>`
        document.getElementById('orgId').innerHTML = `<strong>${org.id}</strong>`
        document.getElementById('region').innerHTML = `<strong>${gc_region}</strong>`

        document.getElementById('startDate').innerHTML = `<strong>${document.getElementById('datepicker').value.split('/')[0]}T00:00:00${document.getElementById('timeZone').value}</strong>`
        document.getElementById('endDate').innerHTML = `<strong>${document.getElementById('datepicker').value.split('/')[1]}T23:59:59${document.getElementById('timeZone').value}</strong>`
      }

      async function getData() {
        console.log('%cGetting data', 'color: green')
        clearData()
        document.getElementById('spinner').style.display = 'block'
        try {
          await setReportData()
          await mosAndRFactor()

          let inbound = await mediaTypeTotals('inbound')
          console.log('%cInbound Media Types: ', 'color: green', inbound)
          // prettier-ignore
          buildColumnChart('incomingMediaTypes', 'Inbound Interactions', [{ key: 'Voice', count: inbound.voice?.length || 0 },{ key: 'Message', count: inbound.message?.length || 0 },{ key: 'Email', count: inbound.email?.length || 0 },{ key: 'Callback', count: inbound.callback?.length || 0 }])
          // prettier-ignore
          buildTableRows('inboundTable', [['Media Type', 'Interactions'],['Voice', inbound.voice?.length || 0],['Message', inbound.message?.length || 0],['Email', inbound.email?.length || 0],['Callback', inbound.callback?.length || 0]])

          let outbound = await mediaTypeTotals('outbound')
          console.log('%cOutbound Media Types: ', 'color: green', outbound)
          // prettier-ignore
          buildColumnChart('outgoingMediaTypes', 'Outbound Interactions', [{ key: 'Voice', count: outbound.voice?.length || 0 },{ key: 'Message', count: outbound.message?.length || 0 },{ key: 'Email', count: outbound.email?.length || 0 },{ key: 'Callback', count: outbound.callback?.length || 0 }])
          // prettier-ignore
          buildTableRows('outboundTable', [['Media Type', 'Interactions'],['Voice', outbound.voice?.length || 0],['Message', outbound.message?.length || 0],['Email', outbound.email?.length || 0],['Callback', outbound.callback?.length || 0]])

          let recordings = await mediaRecordingTotals()
          console.log('%cRecordings: ', 'color: green', recordings)
          // prettier-ignore
          buildColumnChart('recordings', 'Recordings', [{ key: 'Voice', count: recordings.voice?.length || 0 },{ key: 'Message', count: recordings.message?.length || 0 },{ key: 'Email', count: recordings.email?.length || 0 },{ key: 'Callback', count: recordings.callback?.length || 0 }])
          // prettier-ignore
          buildTableRows('recordingsTable', [['Media Type', 'Interactions'],['Voice', recordings.voice?.length || 0],['Message', recordings.message?.length || 0],['Email', recordings.email?.length || 0],['Callback', recordings.callback?.length || 0]])

          let callsPerDay = []
          let inboundCallsPerDay = await interactionsPerDay(inbound.voice, 'inboundVoice')
          let outboundCallsPerDay = await interactionsPerDay(outbound.voice, 'outboundVoice')
          let ci = 0
          for (const day of inboundCallsPerDay) {
            callsPerDay.push([day[0], day[1] + outboundCallsPerDay[ci][1]])
            ci++
          }
          console.log('%cCalls Per Day: ', 'color: green', callsPerDay)
          // prettier-ignore
          buildColumnChart('callsPerDay','Calls Per Day',callsPerDay.map((row) => ({ key: row[0], count: row[1] })))

          let emailsPerDay = []
          let inboundEmailsPerDay = await interactionsPerDay(inbound.email, 'inboundEmail')
          let outboundEmailsPerDay = await interactionsPerDay(outbound.email, 'outboundEmail')
          let ei = 0
          for (const day of inboundEmailsPerDay) {
            emailsPerDay.push([day[0], day[1] + outboundEmailsPerDay[ei][1]])
            ei++
          }
          console.log('%cEmails Per Day: ', 'color: green', emailsPerDay)
          // prettier-ignore
          buildColumnChart('emailsPerDay','Emails Per Day',emailsPerDay.map((row) => ({ key: row[0], count: row[1] })))

          let messagesPerDay = []
          let inboundMessagesPerDay = await interactionsPerDay(inbound.message, 'inboundMessaging')
          let outboundMessagesPerDay = await interactionsPerDay(outbound.message, 'outboundMessaging')
          let mi = 0
          for (const day of inboundMessagesPerDay) {
            messagesPerDay.push([day[0], day[1] + outboundMessagesPerDay[mi][1]])
            mi++
          }
          console.log('%cMessages Per Day: ', 'color: green', messagesPerDay)
          // prettier-ignore
          buildColumnChart('messagesPerDay','Messages Per Day',messagesPerDay.map((row) => ({ key: row[0], count: row[1] })))

          let callbacksPerDay = []
          let inboundCallbacksPerDay = await interactionsPerDay(inbound.callback, 'inboundCallback')
          let outboundCallbacksPerDay = await interactionsPerDay(outbound.callback, 'outboundCallback')
          let cbi = 0
          for (const day of inboundCallbacksPerDay) {
            callbacksPerDay.push([day[0], day[1] + outboundCallbacksPerDay[cbi][1]])
            cbi++
          }
          console.log('%cCallbacks Per Day: ', 'color: green', callbacksPerDay)
          // prettier-ignore
          buildColumnChart('callbacksPerDay','Callbacks Per Day',callbacksPerDay.map((row) => ({ key: row[0], count: row[1] })))

          // prettier-ignore
          buildStackedColumnChart(callsPerDay.map((row) => ({ key: row[0], count: row[1] })), emailsPerDay.map((row) => ({ key: row[0], count: row[1] })), messagesPerDay.map((row) => ({ key: row[0], count: row[1] })), callbacksPerDay.map((row) => ({ key: row[0], count: row[1] })))

          let usersPerDay = await getUsersPerDay()
          // prettier-ignore
          buildColumnChart('usersPerDay','Users Per Day',usersPerDay.map((row) => ({ key: row[0], count: row[1] })))

          document.getElementById('spinner').style.display = 'none'
          document.getElementById('download').style.display = 'block'
        } catch (err) {
          console.log('Error: ', err)
          notification('Error', `Error: ${err}`)
        }
      }

      async function getConversations(pageNumber, query) {
        query.paging.pageNumber = pageNumber
        let conversations = await capi.postAnalyticsConversationsDetailsQuery(query)
        if (pageNumber < Math.ceil(conversations.totalHits / 100)) {
          const nextConversations = await getConversations(pageNumber + 1, query)
          return conversations.conversations.concat(nextConversations)
        }
        return conversations.conversations
      }

      async function mosAndRFactor() {
        let conversations = await getConversations(1, {
          // prettier-ignore
          interval: `${document.getElementById('datepicker').value.split('/')[0]}T00:00:00${document.getElementById('timeZone').value}/${document.getElementById('datepicker').value.split('/')[1]}T23:59:59${document.getElementById('timeZone').value}`,
          order: 'desc',
          orderBy: 'conversationStart',
          paging: {
            pageSize: 100,
            pageNumber: 1,
          },
          conversationFilters: [
            {
              predicates: [
                {
                  type: 'dimension',
                  operator: 'exists',
                  dimension: 'mediaStatsMinConversationMos',
                },
              ],
              type: 'and',
            },
          ],
        })
        console.log('%cTotal MOS & RFactor Conversations: ', 'color: green', conversations)

        // rendering data
        let totalMosInteractions = 0
        let totalRFactorInteractions = 0
        let maxMos = 0
        let totalMos = 0
        let rFactorMax = 0
        let totalRFactor = 0
        let minMos = 4.99
        let rFactorMin = 99.99
        let mosColor = 'green'
        let rFactorColor = 'green'

        for (const conv of conversations) {
          // only if they have MOS data
          if (conv?.mediaStatsMinConversationMos) {
            ++totalMosInteractions
            let mos = Math.round(conv.mediaStatsMinConversationMos * 100) / 100
            if (mos < minMos) {
              minMos = mos
            }
            if (mos > maxMos) {
              maxMos = mos
            }
            totalMos += mos
          }
          // only if they have R-Factor data
          if (conv?.mediaStatsMinConversationRFactor) {
            ++totalRFactorInteractions
            let rFactor = Math.round(conv.mediaStatsMinConversationRFactor * 100) / 100
            if (rFactor < rFactorMin) {
              rFactorMin = rFactor
            }
            if (rFactor > rFactorMax) {
              rFactorMax = rFactor
            }
            totalRFactor += rFactor
          }
        }
        let averageMos = Math.round((totalMos / conversations.length) * 100) / 100
        let averageRFactor = Math.round((totalRFactor / conversations.length) * 100) / 100
        if (minMos < 3.5) {
          mosColor = 'red'
        }
        if (rFactorMin < 50) {
          rFactorColor = 'red'
        }
        // prettier-ignore
        document.getElementById('mosLabel').innerHTML = `<div style="display: inline-flex; width: 100%; justify-content: space-evenly;"><h5>MOS Total Interactions: ${totalMosInteractions}</h5><h5>Min: <strong style="color: ${mosColor}"> â–¼ ${minMos}</strong></h5><h5>Max: <strong  style="color: green"> â–² ${maxMos}</strong></h5><h5>Average: ðŸ“ˆ ${averageMos}</h5></div>`
        // prettier-ignore
        document.getElementById('rFactorLabel').innerHTML = `<div style="display: inline-flex; width: 100%; justify-content: space-evenly;"><h5>MOS Total Interactions: ${totalRFactorInteractions}</h5><h5>Min: <strong style="color: ${rFactorColor}"> â–¼ ${rFactorMin}</strong></h5><h5>Max: <strong  style="color: green"> â–² ${rFactorMax}</strong></h5><h5>Average: ðŸ“ˆ ${averageRFactor}</h5></div>`
      }

      async function buildColumnChart(destination, title, data) {
        new Chart(document.getElementById(destination), {
          type: 'bar',
          data: {
            labels: data.map((row) => row.key),
            datasets: [
              {
                label: title || 'Unknown',
                data: data.map((row) => row.count),
              },
            ],
          },
        })
      }

      async function buildStackedColumnChart(voice, email, message, callback) {
        let data = {
          labels: voice.map((row) => row.key), //['Date-1', 'Date-2', 'Date-3', 'Date-4', 'Date-5'],
          datasets: [
            {
              label: 'Call',
              data: voice.map((row) => row.count), //[10, 20, 15, 25, 30],
              backgroundColor: 'rgba(255, 99, 132, 0.6)', // Red with some transparency
              borderColor: 'rgba(255, 99, 132, 1)',
            },
            {
              label: 'Email',
              data: email.map((row) => row.count),
              backgroundColor: 'rgba(54, 162, 235, 0.6)', // Blue with some transparency
              borderColor: 'rgba(54, 162, 235, 1)',
            },
            {
              label: 'Message',
              data: message.map((row) => row.count),
              backgroundColor: 'rgba(255, 206, 86, 0.6)', // Yellow with some transparency
              borderColor: 'rgba(255, 206, 86, 1)',
            },
            {
              label: 'Callback',
              data: callback.map((row) => row.count),
              backgroundColor: 'rgba(75, 192, 192, 0.6)', // Green with some transparency
              borderColor: 'rgb(75, 192, 1)',
            },
          ],
        }
        new Chart(document.getElementById('interactionsPerDay'), {
          type: 'bar',
          data: data,
          options: {
            responsive: true,
            maintainAspectRatio: true,
            scales: {
              x: {
                stacked: true,
              },
              y: {
                stacked: true,
                beginAtZero: true,
              },
            },
            plugins: {
              title: {
                display: true,
                text: 'Interactions',
                font: {
                  size: 18,
                },
              },
              tooltip: {
                mode: 'index',
                intersect: false,
              },
            },
          },
        })
      }

      async function mediaTypeTotals(direction) {
        // Voice
        let conversationsVoice = await getConversations(1, {
          // prettier-ignore
          interval: `${document.getElementById('datepicker').value.split('/')[0]}T00:00:00${document.getElementById('timeZone').value}/${document.getElementById('datepicker').value.split('/')[1]}T23:59:59${document.getElementById('timeZone').value}`,
          order: 'desc',
          orderBy: 'conversationStart',
          paging: {
            pageSize: 100,
            pageNumber: 1,
          },
          conversationFilters: [
            {
              type: 'and',
              predicates: [
                {
                  metric: 'nConnected',
                  operator: 'exists',
                },
              ],
            },
          ],
          segmentFilters: [
            {
              predicates: [
                {
                  dimension: 'mediaType',
                  value: 'voice',
                  operator: 'matches',
                },
                {
                  dimension: 'direction',
                  operator: 'matches',
                  value: direction,
                },
              ],
              type: 'and',
            },
          ],
        })

        // Messaging
        let conversationsMessaging = await getConversations(1, {
          // prettier-ignore
          interval: `${document.getElementById('datepicker').value.split('/')[0]}T00:00:00${document.getElementById('timeZone').value}/${document.getElementById('datepicker').value.split('/')[1]}T23:59:59${document.getElementById('timeZone').value}`,
          order: 'desc',
          orderBy: 'conversationStart',
          paging: {
            pageSize: 100,
            pageNumber: 1,
          },
          conversationFilters: [
            {
              type: 'and',
              predicates: [
                {
                  metric: 'nConnected',
                  operator: 'exists',
                },
              ],
            },
          ],
          segmentFilters: [
            {
              predicates: [
                {
                  dimension: 'mediaType',
                  value: 'message',
                  operator: 'matches',
                },
                {
                  dimension: 'direction',
                  operator: 'matches',
                  value: direction,
                },
              ],
              type: 'and',
            },
          ],
        })

        // Email
        let conversationsEmail = await getConversations(1, {
          // prettier-ignore
          interval: `${document.getElementById('datepicker').value.split('/')[0]}T00:00:00${document.getElementById('timeZone').value}/${document.getElementById('datepicker').value.split('/')[1]}T23:59:59${document.getElementById('timeZone').value}`,
          order: 'desc',
          orderBy: 'conversationStart',
          paging: {
            pageSize: 100,
            pageNumber: 1,
          },
          conversationFilters: [
            {
              type: 'and',
              predicates: [
                {
                  metric: 'nConnected',
                  operator: 'exists',
                },
              ],
            },
          ],
          segmentFilters: [
            {
              predicates: [
                {
                  dimension: 'mediaType',
                  value: 'email',
                  operator: 'matches',
                },
                {
                  dimension: 'direction',
                  operator: 'matches',
                  value: direction,
                },
              ],
              type: 'and',
            },
          ],
        })

        // Callback
        let conversationsCallBack = await getConversations(1, {
          // prettier-ignore
          interval: `${document.getElementById('datepicker').value.split('/')[0]}T00:00:00${document.getElementById('timeZone').value}/${document.getElementById('datepicker').value.split('/')[1]}T23:59:59${document.getElementById('timeZone').value}`,
          order: 'asc',
          orderBy: 'conversationStart',
          paging: {
            pageSize: 100,
            pageNumber: 1,
          },
          conversationFilters: [
            {
              type: 'and',
              predicates: [
                {
                  metric: 'nConnected',
                  operator: 'exists',
                },
              ],
            },
          ],
          segmentFilters: [
            {
              predicates: [
                {
                  dimension: 'mediaType',
                  value: 'callback',
                  operator: 'matches',
                },
                {
                  dimension: 'direction',
                  operator: 'matches',
                  value: direction,
                },
              ],
              type: 'and',
            },
          ],
        })
        return { voice: conversationsVoice, message: conversationsMessaging, email: conversationsEmail, callback: conversationsCallBack }
      }

      async function mediaRecordingTotals() {
        // Voice
        let conversationsVoice = await getConversations(1, {
          // prettier-ignore
          interval: `${document.getElementById('datepicker').value.split('/')[0]}T00:00:00${document.getElementById('timeZone').value}/${document.getElementById('datepicker').value.split('/')[1]}T23:59:59${document.getElementById('timeZone').value}`,
          order: 'desc',
          orderBy: 'conversationStart',
          paging: {
            pageSize: 100,
            pageNumber: 1,
          },
          segmentFilters: [
            {
              predicates: [
                {
                  dimension: 'mediaType',
                  value: 'voice',
                  operator: 'matches',
                },
                {
                  dimension: 'recording',
                  operator: 'exists',
                },
              ],
              type: 'and',
            },
          ],
        })

        // Messaging
        let conversationsMessaging = await getConversations(1, {
          // prettier-ignore
          interval: `${document.getElementById('datepicker').value.split('/')[0]}T00:00:00${document.getElementById('timeZone').value}/${document.getElementById('datepicker').value.split('/')[1]}T23:59:59${document.getElementById('timeZone').value}`,
          order: 'desc',
          orderBy: 'conversationStart',
          paging: {
            pageSize: 100,
            pageNumber: 1,
          },
          segmentFilters: [
            {
              predicates: [
                {
                  dimension: 'mediaType',
                  value: 'message',
                  operator: 'matches',
                },
                {
                  dimension: 'recording',
                  operator: 'exists',
                },
              ],
              type: 'and',
            },
          ],
        })

        // Email
        let conversationsEmail = await getConversations(1, {
          // prettier-ignore
          interval: `${document.getElementById('datepicker').value.split('/')[0]}T00:00:00${document.getElementById('timeZone').value}/${document.getElementById('datepicker').value.split('/')[1]}T23:59:59${document.getElementById('timeZone').value}`,
          order: 'desc',
          orderBy: 'conversationStart',
          paging: {
            pageSize: 100,
            pageNumber: 1,
          },
          segmentFilters: [
            {
              predicates: [
                {
                  dimension: 'mediaType',
                  value: 'email',
                  operator: 'matches',
                },
                {
                  dimension: 'recording',
                  operator: 'exists',
                },
              ],
              type: 'and',
            },
          ],
        })

        // Callback
        let conversationsCallBack = await getConversations(1, {
          // prettier-ignore
          interval: `${document.getElementById('datepicker').value.split('/')[0]}T00:00:00${document.getElementById('timeZone').value}/${document.getElementById('datepicker').value.split('/')[1]}T23:59:59${document.getElementById('timeZone').value}`,
          order: 'desc',
          orderBy: 'conversationStart',
          paging: {
            pageSize: 100,
            pageNumber: 1,
          },
          segmentFilters: [
            {
              predicates: [
                {
                  dimension: 'mediaType',
                  value: 'callback',
                  operator: 'matches',
                },
                {
                  dimension: 'recording',
                  operator: 'exists',
                },
              ],
              type: 'and',
            },
          ],
        })
        return { voice: conversationsVoice, message: conversationsMessaging, email: conversationsEmail, callback: conversationsCallBack }
      }

      async function interactionsPerDay(conversations, type) {
        let interactionsPerDay = []
        let startDate = document.getElementById('datepicker').value.split('/')[0]
        let endDate = document.getElementById('datepicker').value.split('/')[1]
        let current = new Date(startDate)
        let last = new Date(endDate)
        while (current <= last) {
          let day = current.toISOString().split('T')[0]
          interactionsPerDay.push([day, 0])
          current.setDate(current.getDate() + 1)
        }
        if (!conversations) {
          console.warn('No conversations supplied for: ', type)
          return interactionsPerDay
        }
        console.log(interactionsPerDay)

        for (const conversation of conversations) {
          let date = new Date(conversation.conversationStart)
          // Convert to local time and format as YYYY-MM-DD
          let localDate = new Date(date.getTime() - date.getTimezoneOffset() * 60000)
          let day = localDate.toISOString().split('T')[0]

          if (!interactionsPerDay.some((row) => row[0] === day)) {
            // do nothing TODO: need to consider async interactions here..
            //interactionsPerDay.push([day, 1])
            console.warn('different start date interaction: ', conversation.id)
          } else {
            let index = interactionsPerDay.findIndex((row) => row[0] === day)
            interactionsPerDay[index][1] += 1
          }
        }
        return interactionsPerDay.sort((a, b) => new Date(a[0]) - new Date(b[0]))
      }

      async function getUsers(pageNumber) {
        let users = await uapi.getUsers({ pageNumber: pageNumber, pageSize: 200, state: 'active' })
        if (pageNumber < Math.ceil(users.total / 200)) {
          const nextUsers = await getUsers(pageNumber + 1)
          return users.entities.concat(nextUsers)
        }
        return users.entities
      }

      async function getUsersPerDay() {
        let usersSearch = []
        let userIds = await getUsers(1)
        for (const user of userIds) {
          usersSearch.push({ dimension: 'userId', value: user.id })
        }
        if (usersSearch.length > 100) {
          // need to page as only 100 agents at a time can be checked
          let userChunks = []
          for (let i = 0; i < usersSearch.length; i += 100) {
            userChunks.push(usersSearch.slice(i, i + 100))
          }
          let users = []
          for (const chunk of userChunks) {
            let result = await uapi.postAnalyticsUsersAggregatesQuery({
              // prettier-ignore
              interval: `${document.getElementById('datepicker').value.split('/')[0]}T00:00:00${document.getElementById('timeZone').value}/${document.getElementById('datepicker').value.split('/')[1]}T23:59:59${document.getElementById('timeZone').value}`,
              granularity: 'P1D',
              groupBy: ['userId'],
              metrics: ['tSystemPresence'],
              filter: {
                type: 'and',
                predicates: chunk,
              },
            })
            users = users.concat(result.results)
          }
          let returnUsers = await formatUsers(users)
          return returnUsers
        } else {
          let users = await uapi.postAnalyticsUsersAggregatesQuery({
            // prettier-ignore
            interval: `${document.getElementById('datepicker').value.split('/')[0]}T00:00:00${document.getElementById('timeZone').value}/${document.getElementById('datepicker').value.split('/')[1]}T23:59:59${document.getElementById('timeZone').value}`,
            granularity: 'P1D',
            groupBy: ['userId'],
            metrics: ['tSystemPresence'],
            filter: {
              type: 'and',
              predicates: usersSearch,
            },
          })
          let returnUsers = await formatUsers(users.results)
          return returnUsers
        }
      }

      async function formatUsers(users) {
        let returnUsers = []
        // set dates in local first to array for chart
        for (const date of users[0].data) {
          let dateSpilt = new Date(date.interval.split('/')[0])
          // Convert to local time and format as YYYY-MM-DD
          let localDate = new Date(dateSpilt.getTime() - dateSpilt.getTimezoneOffset() * 60000)
          let day = localDate.toISOString().split('T')[0]
          returnUsers.push([day, 0])
        }

        // count up users that have been in stat other then OFFLINE and ++
        for (const user of users) {
          for (const day of user.data) {
            let dateSpilt = new Date(day.interval.split('/')[0])
            // Convert to local time and format as YYYY-MM-DD
            let localDate = new Date(dateSpilt.getTime() - dateSpilt.getTimezoneOffset() * 60000)
            let localDay = localDate.toISOString().split('T')[0]
            let date = returnUsers.find((x) => x[0] == localDay)
            //console.log(date)
            for (const metric of day.metrics) {
              if (metric.qualifier != 'OFFLINE') {
                date[1] = date[1] + 1
                continue
              }
            }
          }
        }
        return returnUsers
      }
    </script>
  </body>
  <style>
    body {
      max-width: 900px;
      justify-self: center;
    }
    .mm-center {
      text-align: center;
      padding: 8px;
      width: auto;
    }
    .mm-card {
      margin: 8px;
      width: auto;
    }
    .mm-chart {
      max-width: 100%;
      max-height: 100%;
    }
    /* Styles specifically for printing */
    @media print {
      .content {
        width: auto;
        float: none;
      }
      a::after {
        content: ' (' attr(href) ')';
        font-size: 80%;
      }
      .header {
        display: none !important;
      }
      gux-card {
        page-break-inside: avoid; /* Prevent card from breaking across pages */
      }
      img {
        max-width: 100%;
      }
    }
  </style>
</html>
